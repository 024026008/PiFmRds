#!/usr/bin/python

# This program uses Pydemod, see https://github.com/ChristopheJacquet/Pydemod

import pydemod.app.rds as rds
import pydemod.modulation.am as am
import numpy
import scipy.io.wavfile as wavfile
import io

sample_rate = 228000

outc = io.open("waveforms.c", mode="w", encoding="utf8")
outh = io.open("waveforms.h", mode="w", encoding="utf8")

header = u"""
/* This file was automatically generated by "generate_waveforms.py".
   (C) 2014 Christophe Jacquet.
   Released under the GNU GPL v3 license.
*/

"""

outc.write(header)
outh.write(header)

def format_number(x):
    if abs(x) < 1e-10:
        return u"0"
    else:
        return unicode(x)

def generate_bit_in_context(prev, current, next):
    name = u"{}{}{}".format(prev, current, next)

    shapedSamples = rds.unmodulated_signal([prev, current, next], sample_rate)

    out = am.modulate(shapedSamples, sample_rate, frequency=57000, phase=0)

    out = out[336:336+192]

    iout = (out * 20000./max(abs(out)) ).astype(numpy.dtype('>i2'))
    wavfile.write(u"{}.wav".format(name), sample_rate, iout)
    
    outc.write(u"float symbol_{name}[] = {{{values}}};\n\n".format(
        name = name,
        values = u", ".join(map(format_number, out))))
    
    outh.write(u"extern float symbol_{name}[];\n".format(name=name))


for prev in [0, 1]:
    for current in [0, 1]:
        for next in [0, 1]:
            generate_bit_in_context(prev, current, next)

outc.close()
outh.close()